import numpy as np
import cv2 as cv


# Find the mean colour of the center of the circle in an image generated by the gadget
def mean_colour(img_bgr):
    # Find the circle's center
    # Hough circles is slow when the resolution of the image is high, and we must resize the image to the adequate size
    # before using it.
    image_height = img_bgr.shape[0]
    factor = 400 / image_height
    img_bgr = cv.resize(img_bgr, (0, 0), fx=factor, fy=factor)
    gray = cv.cvtColor(img_bgr, cv.COLOR_BGR2GRAY)

    blurred = cv.GaussianBlur(gray, (41, 41), 0)
    # cv.imshow('i', blurred)
    # cv.waitKey(0)
    # cv.destroyAllWindows()

    circle = cv.HoughCircles(blurred, cv.HOUGH_GRADIENT, 10, 20000, param1=30, param2=50, minRadius=0, maxRadius=0)

    if circle is not None:
        circle = np.uint16(np.around(circle))

        if len(circle[0]) != 1:
            print("Incorrect number of circles detected")
        else:
            row, col, rad = circle[0][0]
            height, width, depth = img_bgr.shape

            # Code to show if the circles are being correctly found
            # cv.circle(img_bgr, (row, col), rad, (255, 0, 255), 5)
            # cv.imshow('i', img_bgr)
            # cv.waitKey(0)
            # cv.destroyAllWindows()

            # Circle mask
            circle_mask = np.zeros((height, width), np.uint8)
            cv.circle(circle_mask, (row, col), int(rad / 2), 1, thickness=-1)

            # Obtain image in various colour scales
            img_hsv = cv.cvtColor(img_bgr, cv.COLOR_BGR2HSV)
            img_lab = cv.cvtColor(img_bgr, cv.COLOR_BGR2LAB)
            img_yuv = cv.cvtColor(img_bgr, cv.COLOR_BGR2YUV)

            means = [cv.mean(img_bgr, mask=circle_mask)[:-1], cv.mean(img_hsv, mask=circle_mask)[:-1],
                     cv.mean(img_lab, mask=circle_mask)[:-1], cv.mean(img_yuv, mask=circle_mask)[:-1]]

            return means


# Find the distance between two BGR colours
def dist_bgr(col1, col2):
    return np.sqrt((col1[0] - col2[0]) ** 2 + (col1[1] - col2[1]) ** 2 + (col1[2] - col2[2]) ** 2)


# Find the distance between two HSV colours
def dist_hsv(col1, col2):
    # Find the hue distance (it's range is [0, 179] and it is circular)
    hue_dif = abs(col1[0] - col2[0])
    h_dist = min(hue_dif, 180 - hue_dif)

    # Find the distances between s and v
    s_dist = abs(col1[1] - col2[1])
    v_dist = abs(col1[2] - col2[2])

    return np.sqrt(h_dist ** 2 + s_dist ** 2 + v_dist ** 2)


def dist_lab(Lab1, Lab2, **kwargs):
    """
    Returns the difference :math:`\Delta E_{ab}` between two given *CIE Lab*
    *array_like* colours using CIE 2000 recommendation.

    Parameters
    ----------
    Lab1 : array_like, (3,)
        *CIE Lab* *array_like* colour 1.
    Lab2 : array_like, (3,)
        *CIE Lab* *array_like* colour 2.
    \*\*kwargs : \*\*, optional
        Unused parameter provided for signature compatibility with other
        :math:`\Delta E_{ab}` computation objects.

    Returns
    -------
    numeric
        Colour difference :math:`\Delta E_{ab}`.

    References
    ----------

    .. [4]  Lindbloom, B. (2009). Delta E (CIE 2000). Retrieved February 24,
            2014, from http://brucelindbloom.com/Eqn_DeltaE_CIE2000.html

    Examples
    --------
    >>> Lab1 = np.array([100, 21.57210357, 272.2281935])
    >>> Lab2 = np.array([100, 426.67945353, 72.39590835])
    >>> delta_E_CIE2000(Lab1, Lab2)  # doctest: +ELLIPSIS
    94.0356490...
    """

    L1, a1, b1 = np.ravel(Lab1)
    L2, a2, b2 = np.ravel(Lab2)

    kL = 1
    kC = 1
    kH = 1

    l_bar_prime = 0.5 * (L1 + L2)

    c1 = np.sqrt(a1 * a1 + b1 * b1)
    c2 = np.sqrt(a2 * a2 + b2 * b2)

    c_bar = 0.5 * (c1 + c2)
    c_bar7 = np.power(c_bar, 7)

    g = 0.5 * (1 - np.sqrt(c_bar7 / (c_bar7 + 25 ** 7)))

    a1_prime = a1 * (1 + g)
    a2_prime = a2 * (1 + g)
    c1_prime = np.sqrt(a1_prime * a1_prime + b1 * b1)
    c2_prime = np.sqrt(a2_prime * a2_prime + b2 * b2)
    c_bar_prime = 0.5 * (c1_prime + c2_prime)

    h1_prime = (np.arctan2(b1, a1_prime) * 180) / np.pi
    if h1_prime < 0:
        h1_prime += 360

    h2_prime = (np.arctan2(b2, a2_prime) * 180) / np.pi
    if h2_prime < 0.0:
        h2_prime += 360

    h_bar_prime = (0.5 * (h1_prime + h2_prime + 360)
                   if np.fabs(h1_prime - h2_prime) > 180 else
                   0.5 * (h1_prime + h2_prime))

    t = (1 - 0.17 * np.cos(np.pi * (h_bar_prime - 30) / 180) +
         0.24 * np.cos(np.pi * (2 * h_bar_prime) / 180) +
         0.32 * np.cos(np.pi * (3 * h_bar_prime + 6) / 180) -
         0.20 * np.cos(np.pi * (4 * h_bar_prime - 63) / 180))

    if np.fabs(h2_prime - h1_prime) <= 180:
        delta_h_prime = h2_prime - h1_prime
    else:
        delta_h_prime = (h2_prime - h1_prime + 360
                         if h2_prime <= h1_prime else
                         h2_prime - h1_prime - 360)

    delta_L_prime = L2 - L1
    delta_C_prime = c2_prime - c1_prime
    delta_H_prime = (2 * np.sqrt(c1_prime * c2_prime) *
                     np.sin(np.pi * (0.5 * delta_h_prime) / 180))

    sL = 1 + ((0.015 * (l_bar_prime - 50) * (l_bar_prime - 50)) /
              np.sqrt(20 + (l_bar_prime - 50) * (l_bar_prime - 50)))
    sC = 1 + 0.045 * c_bar_prime
    sH = 1 + 0.015 * c_bar_prime * t

    delta_theta = (30 * np.exp(-((h_bar_prime - 275) / 25) *
                               ((h_bar_prime - 275) / 25)))

    c_bar_prime7 = c_bar_prime ** 7

    rC = np.sqrt(c_bar_prime7 / (c_bar_prime7 + 25 ** 7))
    rT = -2 * rC * np.sin(np.pi * (2 * delta_theta) / 180)

    return np.sqrt(
        (delta_L_prime / (kL * sL)) * (delta_L_prime / (kL * sL)) +
        (delta_C_prime / (kC * sC)) * (delta_C_prime / (kC * sC)) +
        (delta_H_prime / (kH * sH)) * (delta_H_prime / (kH * sH)) +
        (delta_C_prime / (kC * sC)) * (delta_H_prime / (kH * sH)) * rT)


# Find the distance between two YUV colours
def dist_yuv(col1, col2):
    return np.sqrt((col1[0] - col2[0]) ** 2 + (col1[1] - col2[1]) ** 2 + (col1[2] - col2[2]) ** 2)
